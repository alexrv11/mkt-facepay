/* eslint-disable jsx-a11y/label-has-for */

/**
 * Component dependencies
 */
const React = require('react');
const PropTypes = require('prop-types');
const classNames = require('classnames');
const { Widther } = require('@andes/common');
const autosize = require('autosize');

/**
 * TextField
 */

const ValidatedIcon = require('./ValidatedIcon');

const namespace = 'andes-form-control';

class TextField extends React.Component {
  constructor(props) {
    super(props);

    const value = props.defaultValue || props.value;

    this.state = {
      height: 'auto',
      countdown: (value || '').length,
      focused: props.autoFocus,
      value,
    };

    this.setField = this.setField.bind(this);
    this.onBlurHandler = this.onBlurHandler.bind(this);
    this.onFocusHandler = this.onFocusHandler.bind(this);
    this.onInputHandler = this.onInputHandler.bind(this);
    this.onChangeHandler = this.onChangeHandler.bind(this);
  }

  componentDidMount() {
    if (this.props.multiline) {
      autosize(this.field);
    }

    if (this.props.focus) {
      this.field.focus();
    }

    if (this.props.select) {
      this.field.focus();
    }
  }

  componentWillReceiveProps(nextProps) {
    const field = this.field;

    if (this.props.multiline) {
      autosize.update(field);
    }

    if (nextProps.value !== this.props.value) {
      this.setState({ value: nextProps.value });
    }

    if (nextProps.focus) {
      this.field.focus();
    }

    if (nextProps.select) {
      this.field.select();
    }

    // Count characters
    if (nextProps.countdown && nextProps.value && nextProps.value !== field.value) {
      this.setState({ countdown: nextProps.value.length });
    }
  }

  onBlurHandler(event) {
    this.setState({ focused: false });
    if (this.props.onBlur) {
      this.props.onBlur(event);
    }
  }

  onFocusHandler(event) {
    this.setState({ focused: true });
    if (this.props.onFocus) {
      this.props.onFocus(event);
    }
  }

  onInputHandler() {
    const stateChanges = { value: this.field.value };
    // Count characters
    if (this.props.countdown) {
      stateChanges.countdown = this.field.value.length;
    }
    this.setState(stateChanges);

    if (this.props.onInput) {
      this.props.onInput(this.field.value);
    }
  }

  onChangeHandler(event) {
    this.props.onChange(event);
  }

  setField(field) {
    if (this.props.setField) {
      this.props.setField(field);
    }
    this.field = field;
  }

  isEmpty(value) {
    return !value && !(value || '').trim();
  }

  render() {
    const {
      className,
      countdown,
      centered,
      disabled,
      message,
      messageShow,
      messageFixed,
      label,
      labelFixed,
      maxLength,
      multiline,
      prefix,
      suffix,
      textbox,
      children,
      modifier,
      focus,
      select,
      setField,
      ...inputProps
    } = this.props;

    const floated = this.state.focused || !this.isEmpty(this.props.value) || this.state.value;
    const classes = classNames(
      namespace,
      `${namespace}--textfield`,
      multiline && `${namespace}--multiline`,
      countdown && `${namespace}--countdown`,
      centered && `${namespace}--centered`,
      this.state.focused && `${namespace}--focused`,
      textbox && `${namespace}--textbox`,
      modifier !== 'default' && `${namespace}--${modifier}`,
      disabled && `${namespace}--disabled`,
      floated && `${namespace}--floated`,
      className,
    );

    const fieldProps = {
      ...inputProps,
      className: `${namespace}__field`,
      disabled,
      maxLength,
      onBlur: this.onBlurHandler,
      onFocus: this.onFocusHandler,
      onInput: this.onInputHandler,
      onChange: this.props.onChange ?
        this.onChangeHandler : null,
      style: multiline ? { height: this.state.height } : null,
      ref: this.setField,
      placeholder: floated || !this.props.label || this.props.labelFixed ? this.props.placeholder : null,
    };

    const Field = multiline ? 'textarea' : 'input';
    const borderClass = classNames(
      `${namespace}__border`,
    );
    const messageClass = classNames(
      `${namespace}__message`,
      messageFixed && `${namespace}__message-fixed`,
    );
    const labelClass = classNames(
      `${namespace}__label`,
      labelFixed && `${namespace}__label-fixed`,
    );

    return (
      <label className={classes}>
        <div className={`${namespace}__control`}>
          {prefix && floated &&
            <span className={`${namespace}__prefix`}>{prefix}</span>}
          {label && <span className={labelClass}>{label}</span>}
          <Field key="field" {...fieldProps} />
          {suffix && floated &&
            <span className={`${namespace}__suffix`}>{suffix}</span>}
          {children && <div className={`${namespace}__embedded`}> {children} </div>}
        </div>
        <div className={borderClass} />
        {modifier === 'completed' && <ValidatedIcon namespace={namespace} />}
        {messageShow && <span className={messageClass}>{message}</span>}
        {countdown && <span className={`${namespace}__countdown`}>{this.state.countdown} / {maxLength}</span>}
      </label>
    );
  }
}

/**
 * Prop types
 */
TextField.propTypes = {
  autoFocus: PropTypes.bool,
  focus: PropTypes.bool,
  select: PropTypes.bool,
  className: PropTypes.string,
  countdown: PropTypes.bool,
  centered: PropTypes.bool,
  defaultValue: PropTypes.string,
  value: PropTypes.oneOfType([
    PropTypes.number,
    PropTypes.string,
  ]),
  placeholder: PropTypes.string,
  disabled: PropTypes.bool,
  message: PropTypes.string,
  messageShow: PropTypes.bool,
  messageFixed: PropTypes.bool,
  label: PropTypes.string,
  labelFixed: PropTypes.bool,
  maxLength: PropTypes.oneOfType([
    PropTypes.number,
    PropTypes.string,
  ]),
  onChange: PropTypes.func,
  setField: PropTypes.func,
  multiline: PropTypes.bool,
  onBlur: PropTypes.func,
  onFocus: PropTypes.func,
  onInput: PropTypes.func,
  prefix: PropTypes.string,
  rows: PropTypes.oneOfType([
    PropTypes.number,
    PropTypes.string,
  ]),
  suffix: PropTypes.string,
  textbox: PropTypes.bool,
  children: PropTypes.node,
  modifier: PropTypes.oneOf(['indeterminate', 'completed', 'error', 'default']),
};

TextField.defaultProps = {
  autoFocus: false,
  focus: false,
  className: '',
  countdown: false,
  centered: false,
  defaultValue: undefined,
  value: undefined,
  placeholder: null,
  disabled: false,
  message: null,
  messageFixed: false,
  messageShow: true,
  label: null,
  labelFixed: false,
  maxLength: 120,
  onChange: null,
  setField: null,
  multiline: false,
  onBlur: null,
  onFocus: null,
  prefix: '',
  rows: 1,
  suffix: '',
  textbox: false,
  children: null,
  modifier: 'default',
  select: false,
  onInput: null,
};

/**
 * Export component
 */
module.exports = Widther(TextField);
